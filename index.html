<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>clive.ng</title>
<style>
  /* reset */
  html,body { height:100%; margin:0; }
  body {
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:#fff;
    color:#111;
    overflow-y: scroll;
  }

  /* content so page can scroll */
  main {
    width: min(900px, 90%);
    margin: 3rem auto;
    line-height:1.6;
  }

  /* full-screen SVG overlay */
  .frame-svg {
    position: fixed;
    inset: 0;               /* top:0; right:0; bottom:0; left:0 */
    pointer-events: none;   /* allow clicks through */
    z-index: 9999;
  }

  /* style SVG text */
  .frame-text {
    font-size: 18px;
    letter-spacing: 0.05em;
    fill: #0a0a0a; /* text colour */
  }

  /* reduce visual weight on small screens */
  @media (max-width:600px){
    .frame-text { font-size: 12px; }
  }
</style>
</head>
<body>

<!-- Page content (so scrolling is possible) -->
<main>
  <h1>clive.ng</h1>
  <p>Scroll down and up to see the border text move clockwise or anticlockwise.</p>
  <p>Use this as a UI/UX effect for headers, campaigns or experimental prototypes. The text runs around the page border on an invisible path.</p>

  <!-- filler content to allow scroll -->
  <section>
    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque a neque sed augue interdum tristique. Suspendisse potenti. Praesent sed dui vel ipsum pharetra interdum. Integer pharetra massa a tortor faucibus, id interdum nibh tristique. Vivamus faucibus, lorem ac consequat interdum, elit augue mattis lectus, et luctus justo risus et magna. Integer ac arcu nec mi dictum tristique. Etiam efficitur lectus nec arcu posuere, at vulputate justo elementum.</p>
    <p>(Repeat content to make the page scrollable)</p>
    <p style="height:1400px"></p>
  </section>
</main>

<!-- SVG overlay: path around the viewport -->
<svg class="frame-svg" width="100%" height="100%" preserveAspectRatio="none" aria-hidden="true">
  <!-- path: a rectangle inset a bit from the edges -->
  <path id="borderPath" d="" fill="none" stroke="none"></path>

  <!-- the text that rides the path -->
  <text class="frame-text" dominant-baseline="middle">
    <textPath id="frameTextPath" href="#borderPath" startOffset="0">
      <!-- content inserted by JS -->
    </textPath>
  </text>
</svg>

<script>
/*
  Scrolling Frame Text
  - Creates an inset rectangular SVG path that follows the viewport bounds.
  - Repeats provided text to fill the path and animates startOffset.
  - Clockwise on scroll down, anticlockwise on scroll up.
*/

(function () {
  const textString = " Use this as a UI/UX effect for headers, campaigns or experimental prototypes. The text runs around the page border on an invisible path. ";
  const textRepeatMinChars = 4000; // ensure long enough repeated string

  // DOM elements
  const svg = document.querySelector('.frame-svg');
  const path = document.getElementById('borderPath');
  const textPath = document.getElementById('frameTextPath');

  // animation state
  let pathLength = 0;
  let offset = 0;                // current startOffset in px
  let lastScrollY = window.scrollY;
  let velocity = 0;              // animated velocity (px per frame)
  const speedMultiplier = 0.6;   // tune: how much scroll movement maps to text speed
  const damping = 0.92;          // friction applied to velocity each RAF tick
  let lastFrameTime = performance.now();

  // build long repeated text content
  function buildRepeatedText() {
    // repeat until length of string is big enough
    let s = textString;
    while (s.length < textRepeatMinChars) s += textString;
    return s;
  }

  // update the SVG rectangular path to match viewport size with an inset
  function updatePath() {
    const pad = Math.max(16, Math.min(48, window.innerWidth * 0.02)); // inset padding
    const w = window.innerWidth;
    const h = window.innerHeight;
    // Make a path that goes clockwise around the inset rectangle.
    // Use M -> L -> L -> L -> Z
    const x1 = pad, y1 = pad;
    const x2 = w - pad, y2 = pad;
    const x3 = w - pad, y3 = h - pad;
    const x4 = pad, y4 = h - pad;
    const d = `M ${x1},${y1} L ${x2},${y2} L ${x3},${y3} L ${x4},${y4} Z`;
    path.setAttribute('d', d);

    // get path length
    pathLength = path.getTotalLength();

    // ensure textPath startOffset is within pathLength range
    offset = ((offset % pathLength) + pathLength) % pathLength;
    textPath.setAttribute('startOffset', offset);
  }

  // fill the textPath content with enough repetition to avoid gaps visually
  function populateText() {
    const repeated = buildRepeatedText();
    // Put a very long string; browser will layout it along the path.
    textPath.textContent = repeated;
  }

  // scroll handler - accumulate scroll delta and map to velocity
  function onScroll() {
    const now = performance.now();
    const sy = window.scrollY;
    const delta = sy - lastScrollY; // positive when scrolling down
    lastScrollY = sy;

    // map scroll delta to velocity; scroll down should move text clockwise.
    // We'll treat positive delta (scroll down) as positive velocity that moves the text forward along the path.
    // To make movement feel reasonable, multiply and clamp.
    const mapped = delta * speedMultiplier;
    velocity += mapped;
  }

  // animation loop
  function tick(now) {
    const dt = Math.min(32, now - lastFrameTime); // cap dt for stability
    lastFrameTime = now;

    // apply velocity to offset
    if (Math.abs(velocity) > 0.0001) {
      // movement direction: positive velocity -> subtract offset to move text so it appears clockwise.
      // Depending on the SVG coordinate system and your preference you can invert sign.
      offset = (offset - velocity * (dt / 16)) % pathLength;
      textPath.setAttribute('startOffset', offset);
      velocity *= Math.pow(damping, dt / 16); // apply damping scaled by dt
    }

    requestAnimationFrame(tick);
  }

  // handle resize
  let resizeTimeout = null;
  function onResize() {
    // debounce resize a little
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      updatePath();
    }, 80);
  }

  // initial setup
  function init() {
    populateText();
    updatePath();
    lastScrollY = window.scrollY;

    // listen to scroll and resize
    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', onResize);

    // start RAF
    requestAnimationFrame(tick);
  }

  // run init after DOM ready
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    init();
  } else {
    document.addEventListener('DOMContentLoaded', init);
  }

})();
</script>
</body>
</html>
