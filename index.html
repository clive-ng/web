<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<!-- Google Fonts: Inter -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
<title>** clive.ng **</title>
<style>
  /* reset */
  :root{
    --font-sans: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  }
  html,body { height:100%; margin:0; }
  body {
    font-family: var(--font-sans);
    background:#fff;
    color:#ababab;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    overflow-y: scroll;
  }

  /* content so page can scroll */
  main {
    width: min(900px, 90%);
    margin: 30rem auto;
    line-height:1.6;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  scroll-snap-align: start;
  }

  section {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  scroll-snap-align: start; /* snap each section to top */
}


  /* full-screen SVG overlay */
  .frame-svg {
    position: fixed;
    inset: 0;               /* top:0; right:0; bottom:0; left:0 */
    pointer-events: none;   /* allow clicks through */
    z-index: 9999;
  }

  /* style SVG text */
  .frame-text {
    font-size: 18px;
    font-family: var(--font-sans);
    letter-spacing: 0.05em;
    fill: #0a0a0a; /* text colour */
  }

  /* ensure form controls and common elements inherit Inter */
  input,button,textarea,select { font-family: var(--font-sans); }

  /* ensure SVG text elements use Inter where supported */
  svg, svg text, svg tspan, svg textPath { font-family: var(--font-sans); }

  /* reduce visual weight on small screens */
  @media (max-width:600px){
    .frame-text { font-size: 12px; }
  }
</style>
</head>
<body>

<!-- Page content (so scrolling is possible) -->
<main>
  <h1>clive.ng</h1>
  <p>great ideas usually come from solid research, especially when paired with good observation</p>
  <p>As an experienced learning designer and researcher, I have a strong background in developing multimedia and interactive guides for museums, using constructive feedback and encouragement to help learners deepen their understanding of art and culture. I also have expertise in designing enquiry-based learning experiences within visual communication, applying a design thinking approach to support meaningful and effective education. Additionally, I have conducted user testing for the initial prototypes of the Pedestrian Wayfinding Signage System in Hong Kong, applying my knowledge of user experience and learning design in public communication. Overall, my passion for creating user-centred, interactive learning experiences—combined with extensive experience across both academic and professional settings—makes me a valuable asset to organisations looking to improve learning engagement and outcomes.</p>

  <!-- filler content to allow scroll -->
  <section>
    <p>I am doing...</p>
    <p>As an experienced communication design lecturer and communication designer, I have a strong background in developing multimedia and interactive tools for museums, using constructive criticism and appreciation to help learners deepen their understanding of art. I also have expertise in designing enquiry-based learning in visual communication, using a design thinking approach to create engaging and effective educational experiences. Additionally, I have conducted user tests for the first prototypes of the Pedestrian Wayfinding Signage System in Hong Kong while applying my knowledge of user experience design. Overall, my passion for creating user-centered interactive media and my extensive experience in both academia and industry make me a valuable asset to any organization seeking to enhance the user experience of their products and services.</p>
    <p style="height:1400px"></p>
  </section>
</main>

<!-- SVG overlay: path around the viewport -->
<svg class="frame-svg" width="100%" height="100%" preserveAspectRatio="none" aria-hidden="true">
  <!-- path: a rectangle inset a bit from the edges -->
  <path id="borderPath" d="" fill="none" stroke="none"></path>

  <!-- the text that rides the path -->
  <text class="frame-text" dominant-baseline="middle">
    <textPath id="frameTextPath" href="#borderPath" startOffset="0">
      <!-- content inserted by JS -->
    </textPath>
  </text>
</svg>

<script>
/*
  Scrolling Frame Text
  - Creates an inset rectangular SVG path that follows the viewport bounds.
  - Repeats provided text to fill the path and animates startOffset.
  - Clockwise on scroll down, anticlockwise on scroll up.
*/

(function () {
  const textString = " 🎓💡🎨💻🏛️💬🌱🧠🖼️💡📚🧭🚶‍♀️🚏🇭🇰🖱️🗣️✨🎯🎓💼📈 ";
  const textRepeatMinChars = 4000; // ensure long enough repeated string

  // DOM elements
  const svg = document.querySelector('.frame-svg');
  const path = document.getElementById('borderPath');
  const textPath = document.getElementById('frameTextPath');

  // animation state
  let pathLength = 0;
  let offset = 0;                // current startOffset in px
  let lastScrollY = window.scrollY;
  let velocity = 0;              // animated velocity (px per frame)
  const speedMultiplier = 0.6;   // tune: how much scroll movement maps to text speed
  const damping = 0.92;          // friction applied to velocity each RAF tick
  let lastFrameTime = performance.now();

  // build long repeated text content
  function buildRepeatedText() {
    // repeat until length of string is big enough
    let s = textString;
    while (s.length < textRepeatMinChars) s += textString;
    return s;
  }

  // update the SVG rectangular path to match viewport size with an inset
  function updatePath() {
    const pad = Math.max(16, Math.min(48, window.innerWidth * 0.02)); // inset padding
    const w = window.innerWidth;
    const h = window.innerHeight;
    // Make a path that goes clockwise around the inset rectangle.
    // Use M -> L -> L -> L -> Z
    const x1 = pad, y1 = pad;
    const x2 = w - pad, y2 = pad;
    const x3 = w - pad, y3 = h - pad;
    const x4 = pad, y4 = h - pad;
    const d = `M ${x1},${y1} L ${x2},${y2} L ${x3},${y3} L ${x4},${y4} Z`;
    path.setAttribute('d', d);

    // get path length
    pathLength = path.getTotalLength();

    // ensure textPath startOffset is within pathLength range
    offset = ((offset % pathLength) + pathLength) % pathLength;
    textPath.setAttribute('startOffset', offset);
  }

  // fill the textPath content with enough repetition to avoid gaps visually
  function populateText() {
    const repeated = buildRepeatedText();
    // Put a very long string; browser will layout it along the path.
    textPath.textContent = repeated;
  }

  // scroll handler - accumulate scroll delta and map to velocity
  function onScroll() {
    const now = performance.now();
    const sy = window.scrollY;
    const delta = sy - lastScrollY; // positive when scrolling down
    lastScrollY = sy;

    // map scroll delta to velocity; scroll down should move text clockwise.
    // We'll treat positive delta (scroll down) as positive velocity that moves the text forward along the path.
    // To make movement feel reasonable, multiply and clamp.
    const mapped = delta * speedMultiplier;
    velocity += mapped;
  }

  // animation loop
  function tick(now) {
    const dt = Math.min(32, now - lastFrameTime); // cap dt for stability
    lastFrameTime = now;

    // apply velocity to offset
    if (Math.abs(velocity) > 0.0001) {
      // movement direction: positive velocity -> subtract offset to move text so it appears clockwise.
      // Depending on the SVG coordinate system and your preference you can invert sign.
      offset = (offset - velocity * (dt / 16)) % pathLength;
      textPath.setAttribute('startOffset', offset);
      velocity *= Math.pow(damping, dt / 16); // apply damping scaled by dt
    }

    requestAnimationFrame(tick);
  }

  // handle resize
  let resizeTimeout = null;
  function onResize() {
    // debounce resize a little
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      updatePath();
    }, 80);
  }

  // initial setup
  function init() {
    populateText();
    updatePath();
    lastScrollY = window.scrollY;

    // listen to scroll and resize
    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', onResize);

    // start RAF
    requestAnimationFrame(tick);
  }

  // run init after DOM ready
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    init();
  } else {
    document.addEventListener('DOMContentLoaded', init);
  }

})();
</script>
</body>
</html>
