<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Batch Cleaner Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #e2e8f0; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #cbd5e1; }
        @keyframes pulse-soft { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .animate-pulse-soft { animation: pulse-soft 2s infinite; }
    </style>
</head>
<body class="bg-slate-50 font-sans text-slate-900">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef } = React;

        const App = () => {
            const apiKey = "AIzaSyAw_XAEgiSNPXfduMG12c6UiXnmHOfln3c"; 
            const MODEL_ENDPOINT = "gemini-2.0-flash"; 

            const [images, setImages] = useState([]);
            const [prompt, setPrompt] = useState("Remove all text and handwriting from the dress, leaving it plain and clean. Keep the original school logo. Professional photography quality.");
            const [namePrefix, setNamePrefix] = useState("unitf");
            const [downloadCount, setDownloadCount] = useState(1);
            const [zeroPadding, setZeroPadding] = useState(3);
            const [isProcessing, setIsProcessing] = useState(false);
            const [isDragging, setIsDragging] = useState(false);
            const fileInputRef = useRef(null);

            const processFiles = (files) => {
                const validFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
                validFiles.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImages(prev => [...prev, {
                            id: crypto.randomUUID(),
                            dataUrl: e.target.result,
                            status: 'idle',
                            fileName: null,
                            resultUrl: null,
                            error: null
                        }]);
                    };
                    reader.readAsDataURL(file);
                });
            };

            // Fix for Drag and Drop
            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    processFiles(e.dataTransfer.files);
                }
            };

            const handleGenerateBatch = async () => {
                const pending = images.filter(img => img.status === 'idle' || img.status === 'error');
                if (pending.length === 0 || isProcessing) return;

                setIsProcessing(true);
                let currentCounter = downloadCount;

                for (const img of pending) {
                    setImages(prev => prev.map(i => i.id === img.id ? { ...i, status: 'processing', error: null } : i));

                    try {
                        const base64Data = img.dataUrl.split(',')[1];
                        const mimeType = img.dataUrl.match(/data:(.*?);base64/)[1];

                        const response = await fetch(
                            `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_ENDPOINT}:generateContent?key=${apiKey}`,
                            {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    contents: [{
                                        parts: [
                                            { text: prompt },
                                            { inlineData: { mimeType, data: base64Data } }
                                        ]
                                    }],
                                    generationConfig: {
                                        // Some regions require explicit modality settings
                                        responseModalities: ["IMAGE"] 
                                    }
                                })
                            }
                        );

                        const data = await response.json();
                        
                        if (!response.ok) {
                            throw new Error(data.error?.message || "Check API Key or Model access.");
                        }

                        const outPart = data.candidates?.[0]?.content?.parts?.find(p => p.inlineData);
                        
                        if (outPart?.inlineData?.data) {
                            const resultUrl = `data:image/png;base64,${outPart.inlineData.data}`;
                            const finalFileName = `${namePrefix}${String(currentCounter).padStart(zeroPadding, '0')}.png`;
                            
                            setImages(prev => prev.map(i => i.id === img.id ? { 
                                ...i, status: 'done', resultUrl, fileName: finalFileName 
                            } : i));

                            const link = document.createElement('a');
                            link.href = resultUrl;
                            link.download = finalFileName;
                            link.click();

                            currentCounter++;
                            setDownloadCount(currentCounter);
                        } else {
                            throw new Error("AI did not return an image. It may have returned text instead.");
                        }
                    } catch (err) {
                        setImages(prev => prev.map(i => i.id === img.id ? { ...i, status: 'error', error: err.message } : i));
                    }
                }
                setIsProcessing(false);
            };

            return (
                <div className="min-h-screen p-4 md:p-8 max-w-6xl mx-auto space-y-8">
                    <header className="flex items-center gap-4">
                        <div className="p-3 bg-indigo-600 rounded-2xl text-white shadow-lg"><i className="fa-solid fa-wand-magic-sparkles text-2xl"></i></div>
                        <div>
                            <h1 className="text-3xl font-black text-slate-800">Batch Cleaner</h1>
                            <p className="text-slate-400 text-sm font-bold uppercase tracking-widest">Fixed Drag-and-Drop + Modality</p>
                        </div>
                    </header>

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <div className="space-y-6">
                            <section className="bg-white rounded-3xl shadow-sm border border-slate-200 p-6 space-y-4">
                                <div className="flex justify-between items-center font-bold">
                                    <span><i className="fa-solid fa-images text-indigo-500 mr-2"></i> Queue ({images.length})</span>
                                    {images.length > 0 && <button onClick={() => setImages([])} className="text-red-400 text-xs uppercase underline">Clear</button>}
                                </div>
                                
                                <div 
                                    onDragOver={handleDragOver}
                                    onDragLeave={handleDragLeave}
                                    onDrop={handleDrop}
                                    onClick={() => !isProcessing && fileInputRef.current?.click()}
                                    className={`border-2 border-dashed rounded-2xl p-10 text-center cursor-pointer transition-all duration-200
                                    ${isDragging ? 'border-indigo-500 bg-indigo-100 scale-[1.02]' : 'border-slate-200 bg-slate-50 hover:bg-slate-100'}
                                    ${isProcessing ? 'opacity-50 pointer-events-none' : ''}`}
                                >
                                    <input type="file" multiple accept="image/*" className="hidden" ref={fileInputRef} onChange={(e) => processFiles(e.target.files)} />
                                    <i className={`fa-solid ${isDragging ? 'fa-hand-holding-heart bounce text-indigo-500' : 'fa-cloud-arrow-up text-slate-300'} text-4xl mb-2`}></i>
                                    <p className="text-slate-600 font-bold">{isDragging ? "Drop them now!" : "Drag & Drop or Click to Upload"}</p>
                                </div>
                            </section>

                            <section className="bg-white rounded-3xl shadow-sm border border-slate-200 p-6 space-y-4">
                                <div className="grid grid-cols-3 gap-4">
                                    <div><label className="text-[10px] font-bold text-slate-500 uppercase">Prefix</label><input type="text" value={namePrefix} onChange={(e) => setNamePrefix(e.target.value)} className="w-full p-2 bg-slate-50 border rounded-xl font-bold" /></div>
                                    <div><label className="text-[10px] font-bold text-slate-500 uppercase">Start At</label><input type="number" value={downloadCount} onChange={(e) => setDownloadCount(parseInt(e.target.value))} className="w-full p-2 bg-slate-50 border rounded-xl font-bold" /></div>
                                    <div><label className="text-[10px] font-bold text-slate-500 uppercase">Digits</label><select value={zeroPadding} onChange={(e) => setZeroPadding(parseInt(e.target.value))} className="w-full p-2 bg-slate-50 border rounded-xl font-bold font-bold"><option value="1">1</option><option value="2">01</option><option value="3">001</option></select></div>
                                </div>
                                <textarea value={prompt} onChange={(e) => setPrompt(e.target.value)} className="w-full min-h-[100px] p-4 text-xs bg-slate-50 border rounded-2xl font-medium outline-none focus:ring-2 focus:ring-indigo-500" />
                                <button onClick={handleGenerateBatch} disabled={isProcessing || images.length === 0}
                                    className="w-full py-5 bg-indigo-600 hover:bg-indigo-700 disabled:bg-slate-200 text-white font-black rounded-2xl shadow-xl transition-all">
                                    {isProcessing ? <i className="fa-solid fa-sync fa-spin mr-2"></i> : <i className="fa-solid fa-bolt mr-2"></i>}
                                    {isProcessing ? 'Processing Batch...' : 'Run Cleaning Process'}
                                </button>
                            </section>
                        </div>

                        <section className="bg-white rounded-3xl shadow-sm border border-slate-200 p-6 flex flex-col min-h-[500px]">
                            <h2 className="text-lg font-bold text-slate-800 mb-6 flex items-center gap-2"><i className="fa-solid fa-circle-check text-emerald-500"></i> Gallery</h2>
                            <div className="flex-grow overflow-y-auto custom-scrollbar">
                                {images.length === 0 ? (
                                    <div className="h-full flex flex-col items-center justify-center text-slate-300 opacity-50"><i className="fa-solid fa-wand-magic text-5xl mb-4"></i><p className="font-bold">No images processed yet</p></div>
                                ) : (
                                    <div className="grid grid-cols-2 gap-4">
                                        {images.map(img => (
                                            <div key={img.id} className="bg-slate-50 border border-slate-200 rounded-2xl p-2 space-y-2">
                                                <div className="aspect-square rounded-xl overflow-hidden bg-slate-200 flex items-center justify-center">
                                                    {img.status === 'done' ? <img src={img.resultUrl} className="w-full h-full object-contain" /> :
                                                     img.status === 'processing' ? <i className="fa-solid fa-sync fa-spin text-indigo-500 text-2xl"></i> :
                                                     img.status === 'error' ? <div className="p-2 text-[9px] text-red-600 font-bold text-center">{img.error}</div> :
                                                     <i className="fa-solid fa-hourglass-start text-slate-300 text-xl"></i>}
                                                </div>
                                                <p className="text-[10px] font-bold text-slate-500 truncate text-center">{img.fileName || 'Pending'}</p>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </section>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
